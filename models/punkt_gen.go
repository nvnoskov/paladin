package models

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Data) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "USD":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "USD")
				return
			}
			if cap(z.USD) >= int(zb0002) {
				z.USD = (z.USD)[:zb0002]
			} else {
				z.USD = make([]float64, zb0002)
			}
			for za0001 := range z.USD {
				z.USD[za0001], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "USD", za0001)
					return
				}
			}
		case "EUR":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "EUR")
				return
			}
			if cap(z.EUR) >= int(zb0003) {
				z.EUR = (z.EUR)[:zb0003]
			} else {
				z.EUR = make([]float64, zb0003)
			}
			for za0002 := range z.EUR {
				z.EUR[za0002], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "EUR", za0002)
					return
				}
			}
		case "RUB":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "RUB")
				return
			}
			if cap(z.RUB) >= int(zb0004) {
				z.RUB = (z.RUB)[:zb0004]
			} else {
				z.RUB = make([]float64, zb0004)
			}
			for za0003 := range z.RUB {
				z.RUB[za0003], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "RUB", za0003)
					return
				}
			}
		case "KGS":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "KGS")
				return
			}
			if cap(z.KGS) >= int(zb0005) {
				z.KGS = (z.KGS)[:zb0005]
			} else {
				z.KGS = make([]float64, zb0005)
			}
			for za0004 := range z.KGS {
				z.KGS[za0004], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "KGS", za0004)
					return
				}
			}
		case "CNY":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CNY")
				return
			}
			if cap(z.CNY) >= int(zb0006) {
				z.CNY = (z.CNY)[:zb0006]
			} else {
				z.CNY = make([]float64, zb0006)
			}
			for za0005 := range z.CNY {
				z.CNY[za0005], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "CNY", za0005)
					return
				}
			}
		case "GBP":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GBP")
				return
			}
			if cap(z.GBP) >= int(zb0007) {
				z.GBP = (z.GBP)[:zb0007]
			} else {
				z.GBP = make([]float64, zb0007)
			}
			for za0006 := range z.GBP {
				z.GBP[za0006], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "GBP", za0006)
					return
				}
			}
		case "CHF":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CHF")
				return
			}
			if cap(z.CHF) >= int(zb0008) {
				z.CHF = (z.CHF)[:zb0008]
			} else {
				z.CHF = make([]float64, zb0008)
			}
			for za0007 := range z.CHF {
				z.CHF[za0007], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "CHF", za0007)
					return
				}
			}
		case "UZS":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "UZS")
				return
			}
			if cap(z.UZS) >= int(zb0009) {
				z.UZS = (z.UZS)[:zb0009]
			} else {
				z.UZS = make([]float64, zb0009)
			}
			for za0008 := range z.UZS {
				z.UZS[za0008], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "UZS", za0008)
					return
				}
			}
		case "JPY":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "JPY")
				return
			}
			if cap(z.JPY) >= int(zb0010) {
				z.JPY = (z.JPY)[:zb0010]
			} else {
				z.JPY = make([]float64, zb0010)
			}
			for za0009 := range z.JPY {
				z.JPY[za0009], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "JPY", za0009)
					return
				}
			}
		case "AUD":
			var zb0011 uint32
			zb0011, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AUD")
				return
			}
			if cap(z.AUD) >= int(zb0011) {
				z.AUD = (z.AUD)[:zb0011]
			} else {
				z.AUD = make([]float64, zb0011)
			}
			for za0010 := range z.AUD {
				z.AUD[za0010], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "AUD", za0010)
					return
				}
			}
		case "TRY":
			var zb0012 uint32
			zb0012, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TRY")
				return
			}
			if cap(z.TRY) >= int(zb0012) {
				z.TRY = (z.TRY)[:zb0012]
			} else {
				z.TRY = make([]float64, zb0012)
			}
			for za0011 := range z.TRY {
				z.TRY[za0011], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "TRY", za0011)
					return
				}
			}
		case "AED":
			var zb0013 uint32
			zb0013, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AED")
				return
			}
			if cap(z.AED) >= int(zb0013) {
				z.AED = (z.AED)[:zb0013]
			} else {
				z.AED = make([]float64, zb0013)
			}
			for za0012 := range z.AED {
				z.AED[za0012], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "AED", za0012)
					return
				}
			}
		case "UAH":
			var zb0014 uint32
			zb0014, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "UAH")
				return
			}
			if cap(z.UAH) >= int(zb0014) {
				z.UAH = (z.UAH)[:zb0014]
			} else {
				z.UAH = make([]float64, zb0014)
			}
			for za0013 := range z.UAH {
				z.UAH[za0013], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "UAH", za0013)
					return
				}
			}
		case "THB":
			var zb0015 uint32
			zb0015, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "THB")
				return
			}
			if cap(z.THB) >= int(zb0015) {
				z.THB = (z.THB)[:zb0015]
			} else {
				z.THB = make([]float64, zb0015)
			}
			for za0014 := range z.THB {
				z.THB[za0014], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "THB", za0014)
					return
				}
			}
		case "INR":
			var zb0016 uint32
			zb0016, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "INR")
				return
			}
			if cap(z.INR) >= int(zb0016) {
				z.INR = (z.INR)[:zb0016]
			} else {
				z.INR = make([]float64, zb0016)
			}
			for za0015 := range z.INR {
				z.INR[za0015], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "INR", za0015)
					return
				}
			}
		case "EGP":
			var zb0017 uint32
			zb0017, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "EGP")
				return
			}
			if cap(z.EGP) >= int(zb0017) {
				z.EGP = (z.EGP)[:zb0017]
			} else {
				z.EGP = make([]float64, zb0017)
			}
			for za0016 := range z.EGP {
				z.EGP[za0016], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "EGP", za0016)
					return
				}
			}
		case "CAD":
			var zb0018 uint32
			zb0018, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CAD")
				return
			}
			if cap(z.CAD) >= int(zb0018) {
				z.CAD = (z.CAD)[:zb0018]
			} else {
				z.CAD = make([]float64, zb0018)
			}
			for za0017 := range z.CAD {
				z.CAD[za0017], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "CAD", za0017)
					return
				}
			}
		case "KPW":
			var zb0019 uint32
			zb0019, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "KPW")
				return
			}
			if cap(z.KPW) >= int(zb0019) {
				z.KPW = (z.KPW)[:zb0019]
			} else {
				z.KPW = make([]float64, zb0019)
			}
			for za0018 := range z.KPW {
				z.KPW[za0018], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "KPW", za0018)
					return
				}
			}
		case "KRW":
			var zb0020 uint32
			zb0020, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "KRW")
				return
			}
			if cap(z.KRW) >= int(zb0020) {
				z.KRW = (z.KRW)[:zb0020]
			} else {
				z.KRW = make([]float64, zb0020)
			}
			for za0019 := range z.KRW {
				z.KRW[za0019], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "KRW", za0019)
					return
				}
			}
		case "MNT":
			var zb0021 uint32
			zb0021, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "MNT")
				return
			}
			if cap(z.MNT) >= int(zb0021) {
				z.MNT = (z.MNT)[:zb0021]
			} else {
				z.MNT = make([]float64, zb0021)
			}
			for za0020 := range z.MNT {
				z.MNT[za0020], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "MNT", za0020)
					return
				}
			}
		case "TMT":
			var zb0022 uint32
			zb0022, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TMT")
				return
			}
			if cap(z.TMT) >= int(zb0022) {
				z.TMT = (z.TMT)[:zb0022]
			} else {
				z.TMT = make([]float64, zb0022)
			}
			for za0021 := range z.TMT {
				z.TMT[za0021], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "TMT", za0021)
					return
				}
			}
		case "GEL":
			var zb0023 uint32
			zb0023, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GEL")
				return
			}
			if cap(z.GEL) >= int(zb0023) {
				z.GEL = (z.GEL)[:zb0023]
			} else {
				z.GEL = make([]float64, zb0023)
			}
			for za0022 := range z.GEL {
				z.GEL[za0022], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "GEL", za0022)
					return
				}
			}
		case "GOLD":
			var zb0024 uint32
			zb0024, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GOLD")
				return
			}
			if cap(z.GOLD) >= int(zb0024) {
				z.GOLD = (z.GOLD)[:zb0024]
			} else {
				z.GOLD = make([]float64, zb0024)
			}
			for za0023 := range z.GOLD {
				z.GOLD[za0023], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "GOLD", za0023)
					return
				}
			}
		case "AZN":
			var zb0025 uint32
			zb0025, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AZN")
				return
			}
			if cap(z.AZN) >= int(zb0025) {
				z.AZN = (z.AZN)[:zb0025]
			} else {
				z.AZN = make([]float64, zb0025)
			}
			for za0024 := range z.AZN {
				z.AZN[za0024], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "AZN", za0024)
					return
				}
			}
		case "BHD":
			var zb0026 uint32
			zb0026, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BHD")
				return
			}
			if cap(z.BHD) >= int(zb0026) {
				z.BHD = (z.BHD)[:zb0026]
			} else {
				z.BHD = make([]float64, zb0026)
			}
			for za0025 := range z.BHD {
				z.BHD[za0025], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "BHD", za0025)
					return
				}
			}
		case "AMD":
			var zb0027 uint32
			zb0027, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AMD")
				return
			}
			if cap(z.AMD) >= int(zb0027) {
				z.AMD = (z.AMD)[:zb0027]
			} else {
				z.AMD = make([]float64, zb0027)
			}
			for za0026 := range z.AMD {
				z.AMD[za0026], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "AMD", za0026)
					return
				}
			}
		case "BYN":
			var zb0028 uint32
			zb0028, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BYN")
				return
			}
			if cap(z.BYN) >= int(zb0028) {
				z.BYN = (z.BYN)[:zb0028]
			} else {
				z.BYN = make([]float64, zb0028)
			}
			for za0027 := range z.BYN {
				z.BYN[za0027], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "BYN", za0027)
					return
				}
			}
		case "BRL":
			var zb0029 uint32
			zb0029, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BRL")
				return
			}
			if cap(z.BRL) >= int(zb0029) {
				z.BRL = (z.BRL)[:zb0029]
			} else {
				z.BRL = make([]float64, zb0029)
			}
			for za0028 := range z.BRL {
				z.BRL[za0028], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "BRL", za0028)
					return
				}
			}
		case "HUF":
			var zb0030 uint32
			zb0030, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HUF")
				return
			}
			if cap(z.HUF) >= int(zb0030) {
				z.HUF = (z.HUF)[:zb0030]
			} else {
				z.HUF = make([]float64, zb0030)
			}
			for za0029 := range z.HUF {
				z.HUF[za0029], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "HUF", za0029)
					return
				}
			}
		case "HKD":
			var zb0031 uint32
			zb0031, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HKD")
				return
			}
			if cap(z.HKD) >= int(zb0031) {
				z.HKD = (z.HKD)[:zb0031]
			} else {
				z.HKD = make([]float64, zb0031)
			}
			for za0030 := range z.HKD {
				z.HKD[za0030], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "HKD", za0030)
					return
				}
			}
		case "DKK":
			var zb0032 uint32
			zb0032, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DKK")
				return
			}
			if cap(z.DKK) >= int(zb0032) {
				z.DKK = (z.DKK)[:zb0032]
			} else {
				z.DKK = make([]float64, zb0032)
			}
			for za0031 := range z.DKK {
				z.DKK[za0031], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "DKK", za0031)
					return
				}
			}
		case "IRR":
			var zb0033 uint32
			zb0033, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "IRR")
				return
			}
			if cap(z.IRR) >= int(zb0033) {
				z.IRR = (z.IRR)[:zb0033]
			} else {
				z.IRR = make([]float64, zb0033)
			}
			for za0032 := range z.IRR {
				z.IRR[za0032], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "IRR", za0032)
					return
				}
			}
		case "KWD":
			var zb0034 uint32
			zb0034, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "KWD")
				return
			}
			if cap(z.KWD) >= int(zb0034) {
				z.KWD = (z.KWD)[:zb0034]
			} else {
				z.KWD = make([]float64, zb0034)
			}
			for za0033 := range z.KWD {
				z.KWD[za0033], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "KWD", za0033)
					return
				}
			}
		case "MYR":
			var zb0035 uint32
			zb0035, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "MYR")
				return
			}
			if cap(z.MYR) >= int(zb0035) {
				z.MYR = (z.MYR)[:zb0035]
			} else {
				z.MYR = make([]float64, zb0035)
			}
			for za0034 := range z.MYR {
				z.MYR[za0034], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "MYR", za0034)
					return
				}
			}
		case "MXN":
			var zb0036 uint32
			zb0036, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "MXN")
				return
			}
			if cap(z.MXN) >= int(zb0036) {
				z.MXN = (z.MXN)[:zb0036]
			} else {
				z.MXN = make([]float64, zb0036)
			}
			for za0035 := range z.MXN {
				z.MXN[za0035], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "MXN", za0035)
					return
				}
			}
		case "MDL":
			var zb0037 uint32
			zb0037, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "MDL")
				return
			}
			if cap(z.MDL) >= int(zb0037) {
				z.MDL = (z.MDL)[:zb0037]
			} else {
				z.MDL = make([]float64, zb0037)
			}
			for za0036 := range z.MDL {
				z.MDL[za0036], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "MDL", za0036)
					return
				}
			}
		case "NOK":
			var zb0038 uint32
			zb0038, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "NOK")
				return
			}
			if cap(z.NOK) >= int(zb0038) {
				z.NOK = (z.NOK)[:zb0038]
			} else {
				z.NOK = make([]float64, zb0038)
			}
			for za0037 := range z.NOK {
				z.NOK[za0037], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "NOK", za0037)
					return
				}
			}
		case "PLN":
			var zb0039 uint32
			zb0039, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PLN")
				return
			}
			if cap(z.PLN) >= int(zb0039) {
				z.PLN = (z.PLN)[:zb0039]
			} else {
				z.PLN = make([]float64, zb0039)
			}
			for za0038 := range z.PLN {
				z.PLN[za0038], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "PLN", za0038)
					return
				}
			}
		case "SAR":
			var zb0040 uint32
			zb0040, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SAR")
				return
			}
			if cap(z.SAR) >= int(zb0040) {
				z.SAR = (z.SAR)[:zb0040]
			} else {
				z.SAR = make([]float64, zb0040)
			}
			for za0039 := range z.SAR {
				z.SAR[za0039], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "SAR", za0039)
					return
				}
			}
		case "XDR":
			var zb0041 uint32
			zb0041, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "XDR")
				return
			}
			if cap(z.XDR) >= int(zb0041) {
				z.XDR = (z.XDR)[:zb0041]
			} else {
				z.XDR = make([]float64, zb0041)
			}
			for za0040 := range z.XDR {
				z.XDR[za0040], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "XDR", za0040)
					return
				}
			}
		case "SGD":
			var zb0042 uint32
			zb0042, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SGD")
				return
			}
			if cap(z.SGD) >= int(zb0042) {
				z.SGD = (z.SGD)[:zb0042]
			} else {
				z.SGD = make([]float64, zb0042)
			}
			for za0041 := range z.SGD {
				z.SGD[za0041], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "SGD", za0041)
					return
				}
			}
		case "TJS":
			var zb0043 uint32
			zb0043, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TJS")
				return
			}
			if cap(z.TJS) >= int(zb0043) {
				z.TJS = (z.TJS)[:zb0043]
			} else {
				z.TJS = make([]float64, zb0043)
			}
			for za0042 := range z.TJS {
				z.TJS[za0042], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "TJS", za0042)
					return
				}
			}
		case "CZK":
			var zb0044 uint32
			zb0044, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CZK")
				return
			}
			if cap(z.CZK) >= int(zb0044) {
				z.CZK = (z.CZK)[:zb0044]
			} else {
				z.CZK = make([]float64, zb0044)
			}
			for za0043 := range z.CZK {
				z.CZK[za0043], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "CZK", za0043)
					return
				}
			}
		case "SEK":
			var zb0045 uint32
			zb0045, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SEK")
				return
			}
			if cap(z.SEK) >= int(zb0045) {
				z.SEK = (z.SEK)[:zb0045]
			} else {
				z.SEK = make([]float64, zb0045)
			}
			for za0044 := range z.SEK {
				z.SEK[za0044], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "SEK", za0044)
					return
				}
			}
		case "ZAR":
			var zb0046 uint32
			zb0046, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ZAR")
				return
			}
			if cap(z.ZAR) >= int(zb0046) {
				z.ZAR = (z.ZAR)[:zb0046]
			} else {
				z.ZAR = make([]float64, zb0046)
			}
			for za0045 := range z.ZAR {
				z.ZAR[za0045], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "ZAR", za0045)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Data) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 45
	// write "USD"
	err = en.Append(0xde, 0x0, 0x2d, 0xa3, 0x55, 0x53, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.USD)))
	if err != nil {
		err = msgp.WrapError(err, "USD")
		return
	}
	for za0001 := range z.USD {
		err = en.WriteFloat64(z.USD[za0001])
		if err != nil {
			err = msgp.WrapError(err, "USD", za0001)
			return
		}
	}
	// write "EUR"
	err = en.Append(0xa3, 0x45, 0x55, 0x52)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.EUR)))
	if err != nil {
		err = msgp.WrapError(err, "EUR")
		return
	}
	for za0002 := range z.EUR {
		err = en.WriteFloat64(z.EUR[za0002])
		if err != nil {
			err = msgp.WrapError(err, "EUR", za0002)
			return
		}
	}
	// write "RUB"
	err = en.Append(0xa3, 0x52, 0x55, 0x42)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.RUB)))
	if err != nil {
		err = msgp.WrapError(err, "RUB")
		return
	}
	for za0003 := range z.RUB {
		err = en.WriteFloat64(z.RUB[za0003])
		if err != nil {
			err = msgp.WrapError(err, "RUB", za0003)
			return
		}
	}
	// write "KGS"
	err = en.Append(0xa3, 0x4b, 0x47, 0x53)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.KGS)))
	if err != nil {
		err = msgp.WrapError(err, "KGS")
		return
	}
	for za0004 := range z.KGS {
		err = en.WriteFloat64(z.KGS[za0004])
		if err != nil {
			err = msgp.WrapError(err, "KGS", za0004)
			return
		}
	}
	// write "CNY"
	err = en.Append(0xa3, 0x43, 0x4e, 0x59)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CNY)))
	if err != nil {
		err = msgp.WrapError(err, "CNY")
		return
	}
	for za0005 := range z.CNY {
		err = en.WriteFloat64(z.CNY[za0005])
		if err != nil {
			err = msgp.WrapError(err, "CNY", za0005)
			return
		}
	}
	// write "GBP"
	err = en.Append(0xa3, 0x47, 0x42, 0x50)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GBP)))
	if err != nil {
		err = msgp.WrapError(err, "GBP")
		return
	}
	for za0006 := range z.GBP {
		err = en.WriteFloat64(z.GBP[za0006])
		if err != nil {
			err = msgp.WrapError(err, "GBP", za0006)
			return
		}
	}
	// write "CHF"
	err = en.Append(0xa3, 0x43, 0x48, 0x46)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CHF)))
	if err != nil {
		err = msgp.WrapError(err, "CHF")
		return
	}
	for za0007 := range z.CHF {
		err = en.WriteFloat64(z.CHF[za0007])
		if err != nil {
			err = msgp.WrapError(err, "CHF", za0007)
			return
		}
	}
	// write "UZS"
	err = en.Append(0xa3, 0x55, 0x5a, 0x53)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.UZS)))
	if err != nil {
		err = msgp.WrapError(err, "UZS")
		return
	}
	for za0008 := range z.UZS {
		err = en.WriteFloat64(z.UZS[za0008])
		if err != nil {
			err = msgp.WrapError(err, "UZS", za0008)
			return
		}
	}
	// write "JPY"
	err = en.Append(0xa3, 0x4a, 0x50, 0x59)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.JPY)))
	if err != nil {
		err = msgp.WrapError(err, "JPY")
		return
	}
	for za0009 := range z.JPY {
		err = en.WriteFloat64(z.JPY[za0009])
		if err != nil {
			err = msgp.WrapError(err, "JPY", za0009)
			return
		}
	}
	// write "AUD"
	err = en.Append(0xa3, 0x41, 0x55, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AUD)))
	if err != nil {
		err = msgp.WrapError(err, "AUD")
		return
	}
	for za0010 := range z.AUD {
		err = en.WriteFloat64(z.AUD[za0010])
		if err != nil {
			err = msgp.WrapError(err, "AUD", za0010)
			return
		}
	}
	// write "TRY"
	err = en.Append(0xa3, 0x54, 0x52, 0x59)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TRY)))
	if err != nil {
		err = msgp.WrapError(err, "TRY")
		return
	}
	for za0011 := range z.TRY {
		err = en.WriteFloat64(z.TRY[za0011])
		if err != nil {
			err = msgp.WrapError(err, "TRY", za0011)
			return
		}
	}
	// write "AED"
	err = en.Append(0xa3, 0x41, 0x45, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AED)))
	if err != nil {
		err = msgp.WrapError(err, "AED")
		return
	}
	for za0012 := range z.AED {
		err = en.WriteFloat64(z.AED[za0012])
		if err != nil {
			err = msgp.WrapError(err, "AED", za0012)
			return
		}
	}
	// write "UAH"
	err = en.Append(0xa3, 0x55, 0x41, 0x48)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.UAH)))
	if err != nil {
		err = msgp.WrapError(err, "UAH")
		return
	}
	for za0013 := range z.UAH {
		err = en.WriteFloat64(z.UAH[za0013])
		if err != nil {
			err = msgp.WrapError(err, "UAH", za0013)
			return
		}
	}
	// write "THB"
	err = en.Append(0xa3, 0x54, 0x48, 0x42)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.THB)))
	if err != nil {
		err = msgp.WrapError(err, "THB")
		return
	}
	for za0014 := range z.THB {
		err = en.WriteFloat64(z.THB[za0014])
		if err != nil {
			err = msgp.WrapError(err, "THB", za0014)
			return
		}
	}
	// write "INR"
	err = en.Append(0xa3, 0x49, 0x4e, 0x52)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.INR)))
	if err != nil {
		err = msgp.WrapError(err, "INR")
		return
	}
	for za0015 := range z.INR {
		err = en.WriteFloat64(z.INR[za0015])
		if err != nil {
			err = msgp.WrapError(err, "INR", za0015)
			return
		}
	}
	// write "EGP"
	err = en.Append(0xa3, 0x45, 0x47, 0x50)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.EGP)))
	if err != nil {
		err = msgp.WrapError(err, "EGP")
		return
	}
	for za0016 := range z.EGP {
		err = en.WriteFloat64(z.EGP[za0016])
		if err != nil {
			err = msgp.WrapError(err, "EGP", za0016)
			return
		}
	}
	// write "CAD"
	err = en.Append(0xa3, 0x43, 0x41, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CAD)))
	if err != nil {
		err = msgp.WrapError(err, "CAD")
		return
	}
	for za0017 := range z.CAD {
		err = en.WriteFloat64(z.CAD[za0017])
		if err != nil {
			err = msgp.WrapError(err, "CAD", za0017)
			return
		}
	}
	// write "KPW"
	err = en.Append(0xa3, 0x4b, 0x50, 0x57)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.KPW)))
	if err != nil {
		err = msgp.WrapError(err, "KPW")
		return
	}
	for za0018 := range z.KPW {
		err = en.WriteFloat64(z.KPW[za0018])
		if err != nil {
			err = msgp.WrapError(err, "KPW", za0018)
			return
		}
	}
	// write "KRW"
	err = en.Append(0xa3, 0x4b, 0x52, 0x57)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.KRW)))
	if err != nil {
		err = msgp.WrapError(err, "KRW")
		return
	}
	for za0019 := range z.KRW {
		err = en.WriteFloat64(z.KRW[za0019])
		if err != nil {
			err = msgp.WrapError(err, "KRW", za0019)
			return
		}
	}
	// write "MNT"
	err = en.Append(0xa3, 0x4d, 0x4e, 0x54)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.MNT)))
	if err != nil {
		err = msgp.WrapError(err, "MNT")
		return
	}
	for za0020 := range z.MNT {
		err = en.WriteFloat64(z.MNT[za0020])
		if err != nil {
			err = msgp.WrapError(err, "MNT", za0020)
			return
		}
	}
	// write "TMT"
	err = en.Append(0xa3, 0x54, 0x4d, 0x54)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TMT)))
	if err != nil {
		err = msgp.WrapError(err, "TMT")
		return
	}
	for za0021 := range z.TMT {
		err = en.WriteFloat64(z.TMT[za0021])
		if err != nil {
			err = msgp.WrapError(err, "TMT", za0021)
			return
		}
	}
	// write "GEL"
	err = en.Append(0xa3, 0x47, 0x45, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GEL)))
	if err != nil {
		err = msgp.WrapError(err, "GEL")
		return
	}
	for za0022 := range z.GEL {
		err = en.WriteFloat64(z.GEL[za0022])
		if err != nil {
			err = msgp.WrapError(err, "GEL", za0022)
			return
		}
	}
	// write "GOLD"
	err = en.Append(0xa4, 0x47, 0x4f, 0x4c, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GOLD)))
	if err != nil {
		err = msgp.WrapError(err, "GOLD")
		return
	}
	for za0023 := range z.GOLD {
		err = en.WriteFloat64(z.GOLD[za0023])
		if err != nil {
			err = msgp.WrapError(err, "GOLD", za0023)
			return
		}
	}
	// write "AZN"
	err = en.Append(0xa3, 0x41, 0x5a, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AZN)))
	if err != nil {
		err = msgp.WrapError(err, "AZN")
		return
	}
	for za0024 := range z.AZN {
		err = en.WriteFloat64(z.AZN[za0024])
		if err != nil {
			err = msgp.WrapError(err, "AZN", za0024)
			return
		}
	}
	// write "BHD"
	err = en.Append(0xa3, 0x42, 0x48, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BHD)))
	if err != nil {
		err = msgp.WrapError(err, "BHD")
		return
	}
	for za0025 := range z.BHD {
		err = en.WriteFloat64(z.BHD[za0025])
		if err != nil {
			err = msgp.WrapError(err, "BHD", za0025)
			return
		}
	}
	// write "AMD"
	err = en.Append(0xa3, 0x41, 0x4d, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AMD)))
	if err != nil {
		err = msgp.WrapError(err, "AMD")
		return
	}
	for za0026 := range z.AMD {
		err = en.WriteFloat64(z.AMD[za0026])
		if err != nil {
			err = msgp.WrapError(err, "AMD", za0026)
			return
		}
	}
	// write "BYN"
	err = en.Append(0xa3, 0x42, 0x59, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BYN)))
	if err != nil {
		err = msgp.WrapError(err, "BYN")
		return
	}
	for za0027 := range z.BYN {
		err = en.WriteFloat64(z.BYN[za0027])
		if err != nil {
			err = msgp.WrapError(err, "BYN", za0027)
			return
		}
	}
	// write "BRL"
	err = en.Append(0xa3, 0x42, 0x52, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BRL)))
	if err != nil {
		err = msgp.WrapError(err, "BRL")
		return
	}
	for za0028 := range z.BRL {
		err = en.WriteFloat64(z.BRL[za0028])
		if err != nil {
			err = msgp.WrapError(err, "BRL", za0028)
			return
		}
	}
	// write "HUF"
	err = en.Append(0xa3, 0x48, 0x55, 0x46)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.HUF)))
	if err != nil {
		err = msgp.WrapError(err, "HUF")
		return
	}
	for za0029 := range z.HUF {
		err = en.WriteFloat64(z.HUF[za0029])
		if err != nil {
			err = msgp.WrapError(err, "HUF", za0029)
			return
		}
	}
	// write "HKD"
	err = en.Append(0xa3, 0x48, 0x4b, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.HKD)))
	if err != nil {
		err = msgp.WrapError(err, "HKD")
		return
	}
	for za0030 := range z.HKD {
		err = en.WriteFloat64(z.HKD[za0030])
		if err != nil {
			err = msgp.WrapError(err, "HKD", za0030)
			return
		}
	}
	// write "DKK"
	err = en.Append(0xa3, 0x44, 0x4b, 0x4b)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DKK)))
	if err != nil {
		err = msgp.WrapError(err, "DKK")
		return
	}
	for za0031 := range z.DKK {
		err = en.WriteFloat64(z.DKK[za0031])
		if err != nil {
			err = msgp.WrapError(err, "DKK", za0031)
			return
		}
	}
	// write "IRR"
	err = en.Append(0xa3, 0x49, 0x52, 0x52)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.IRR)))
	if err != nil {
		err = msgp.WrapError(err, "IRR")
		return
	}
	for za0032 := range z.IRR {
		err = en.WriteFloat64(z.IRR[za0032])
		if err != nil {
			err = msgp.WrapError(err, "IRR", za0032)
			return
		}
	}
	// write "KWD"
	err = en.Append(0xa3, 0x4b, 0x57, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.KWD)))
	if err != nil {
		err = msgp.WrapError(err, "KWD")
		return
	}
	for za0033 := range z.KWD {
		err = en.WriteFloat64(z.KWD[za0033])
		if err != nil {
			err = msgp.WrapError(err, "KWD", za0033)
			return
		}
	}
	// write "MYR"
	err = en.Append(0xa3, 0x4d, 0x59, 0x52)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.MYR)))
	if err != nil {
		err = msgp.WrapError(err, "MYR")
		return
	}
	for za0034 := range z.MYR {
		err = en.WriteFloat64(z.MYR[za0034])
		if err != nil {
			err = msgp.WrapError(err, "MYR", za0034)
			return
		}
	}
	// write "MXN"
	err = en.Append(0xa3, 0x4d, 0x58, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.MXN)))
	if err != nil {
		err = msgp.WrapError(err, "MXN")
		return
	}
	for za0035 := range z.MXN {
		err = en.WriteFloat64(z.MXN[za0035])
		if err != nil {
			err = msgp.WrapError(err, "MXN", za0035)
			return
		}
	}
	// write "MDL"
	err = en.Append(0xa3, 0x4d, 0x44, 0x4c)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.MDL)))
	if err != nil {
		err = msgp.WrapError(err, "MDL")
		return
	}
	for za0036 := range z.MDL {
		err = en.WriteFloat64(z.MDL[za0036])
		if err != nil {
			err = msgp.WrapError(err, "MDL", za0036)
			return
		}
	}
	// write "NOK"
	err = en.Append(0xa3, 0x4e, 0x4f, 0x4b)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.NOK)))
	if err != nil {
		err = msgp.WrapError(err, "NOK")
		return
	}
	for za0037 := range z.NOK {
		err = en.WriteFloat64(z.NOK[za0037])
		if err != nil {
			err = msgp.WrapError(err, "NOK", za0037)
			return
		}
	}
	// write "PLN"
	err = en.Append(0xa3, 0x50, 0x4c, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PLN)))
	if err != nil {
		err = msgp.WrapError(err, "PLN")
		return
	}
	for za0038 := range z.PLN {
		err = en.WriteFloat64(z.PLN[za0038])
		if err != nil {
			err = msgp.WrapError(err, "PLN", za0038)
			return
		}
	}
	// write "SAR"
	err = en.Append(0xa3, 0x53, 0x41, 0x52)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SAR)))
	if err != nil {
		err = msgp.WrapError(err, "SAR")
		return
	}
	for za0039 := range z.SAR {
		err = en.WriteFloat64(z.SAR[za0039])
		if err != nil {
			err = msgp.WrapError(err, "SAR", za0039)
			return
		}
	}
	// write "XDR"
	err = en.Append(0xa3, 0x58, 0x44, 0x52)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.XDR)))
	if err != nil {
		err = msgp.WrapError(err, "XDR")
		return
	}
	for za0040 := range z.XDR {
		err = en.WriteFloat64(z.XDR[za0040])
		if err != nil {
			err = msgp.WrapError(err, "XDR", za0040)
			return
		}
	}
	// write "SGD"
	err = en.Append(0xa3, 0x53, 0x47, 0x44)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SGD)))
	if err != nil {
		err = msgp.WrapError(err, "SGD")
		return
	}
	for za0041 := range z.SGD {
		err = en.WriteFloat64(z.SGD[za0041])
		if err != nil {
			err = msgp.WrapError(err, "SGD", za0041)
			return
		}
	}
	// write "TJS"
	err = en.Append(0xa3, 0x54, 0x4a, 0x53)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TJS)))
	if err != nil {
		err = msgp.WrapError(err, "TJS")
		return
	}
	for za0042 := range z.TJS {
		err = en.WriteFloat64(z.TJS[za0042])
		if err != nil {
			err = msgp.WrapError(err, "TJS", za0042)
			return
		}
	}
	// write "CZK"
	err = en.Append(0xa3, 0x43, 0x5a, 0x4b)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CZK)))
	if err != nil {
		err = msgp.WrapError(err, "CZK")
		return
	}
	for za0043 := range z.CZK {
		err = en.WriteFloat64(z.CZK[za0043])
		if err != nil {
			err = msgp.WrapError(err, "CZK", za0043)
			return
		}
	}
	// write "SEK"
	err = en.Append(0xa3, 0x53, 0x45, 0x4b)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SEK)))
	if err != nil {
		err = msgp.WrapError(err, "SEK")
		return
	}
	for za0044 := range z.SEK {
		err = en.WriteFloat64(z.SEK[za0044])
		if err != nil {
			err = msgp.WrapError(err, "SEK", za0044)
			return
		}
	}
	// write "ZAR"
	err = en.Append(0xa3, 0x5a, 0x41, 0x52)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ZAR)))
	if err != nil {
		err = msgp.WrapError(err, "ZAR")
		return
	}
	for za0045 := range z.ZAR {
		err = en.WriteFloat64(z.ZAR[za0045])
		if err != nil {
			err = msgp.WrapError(err, "ZAR", za0045)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Data) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 45
	// string "USD"
	o = append(o, 0xde, 0x0, 0x2d, 0xa3, 0x55, 0x53, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.USD)))
	for za0001 := range z.USD {
		o = msgp.AppendFloat64(o, z.USD[za0001])
	}
	// string "EUR"
	o = append(o, 0xa3, 0x45, 0x55, 0x52)
	o = msgp.AppendArrayHeader(o, uint32(len(z.EUR)))
	for za0002 := range z.EUR {
		o = msgp.AppendFloat64(o, z.EUR[za0002])
	}
	// string "RUB"
	o = append(o, 0xa3, 0x52, 0x55, 0x42)
	o = msgp.AppendArrayHeader(o, uint32(len(z.RUB)))
	for za0003 := range z.RUB {
		o = msgp.AppendFloat64(o, z.RUB[za0003])
	}
	// string "KGS"
	o = append(o, 0xa3, 0x4b, 0x47, 0x53)
	o = msgp.AppendArrayHeader(o, uint32(len(z.KGS)))
	for za0004 := range z.KGS {
		o = msgp.AppendFloat64(o, z.KGS[za0004])
	}
	// string "CNY"
	o = append(o, 0xa3, 0x43, 0x4e, 0x59)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CNY)))
	for za0005 := range z.CNY {
		o = msgp.AppendFloat64(o, z.CNY[za0005])
	}
	// string "GBP"
	o = append(o, 0xa3, 0x47, 0x42, 0x50)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GBP)))
	for za0006 := range z.GBP {
		o = msgp.AppendFloat64(o, z.GBP[za0006])
	}
	// string "CHF"
	o = append(o, 0xa3, 0x43, 0x48, 0x46)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CHF)))
	for za0007 := range z.CHF {
		o = msgp.AppendFloat64(o, z.CHF[za0007])
	}
	// string "UZS"
	o = append(o, 0xa3, 0x55, 0x5a, 0x53)
	o = msgp.AppendArrayHeader(o, uint32(len(z.UZS)))
	for za0008 := range z.UZS {
		o = msgp.AppendFloat64(o, z.UZS[za0008])
	}
	// string "JPY"
	o = append(o, 0xa3, 0x4a, 0x50, 0x59)
	o = msgp.AppendArrayHeader(o, uint32(len(z.JPY)))
	for za0009 := range z.JPY {
		o = msgp.AppendFloat64(o, z.JPY[za0009])
	}
	// string "AUD"
	o = append(o, 0xa3, 0x41, 0x55, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AUD)))
	for za0010 := range z.AUD {
		o = msgp.AppendFloat64(o, z.AUD[za0010])
	}
	// string "TRY"
	o = append(o, 0xa3, 0x54, 0x52, 0x59)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TRY)))
	for za0011 := range z.TRY {
		o = msgp.AppendFloat64(o, z.TRY[za0011])
	}
	// string "AED"
	o = append(o, 0xa3, 0x41, 0x45, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AED)))
	for za0012 := range z.AED {
		o = msgp.AppendFloat64(o, z.AED[za0012])
	}
	// string "UAH"
	o = append(o, 0xa3, 0x55, 0x41, 0x48)
	o = msgp.AppendArrayHeader(o, uint32(len(z.UAH)))
	for za0013 := range z.UAH {
		o = msgp.AppendFloat64(o, z.UAH[za0013])
	}
	// string "THB"
	o = append(o, 0xa3, 0x54, 0x48, 0x42)
	o = msgp.AppendArrayHeader(o, uint32(len(z.THB)))
	for za0014 := range z.THB {
		o = msgp.AppendFloat64(o, z.THB[za0014])
	}
	// string "INR"
	o = append(o, 0xa3, 0x49, 0x4e, 0x52)
	o = msgp.AppendArrayHeader(o, uint32(len(z.INR)))
	for za0015 := range z.INR {
		o = msgp.AppendFloat64(o, z.INR[za0015])
	}
	// string "EGP"
	o = append(o, 0xa3, 0x45, 0x47, 0x50)
	o = msgp.AppendArrayHeader(o, uint32(len(z.EGP)))
	for za0016 := range z.EGP {
		o = msgp.AppendFloat64(o, z.EGP[za0016])
	}
	// string "CAD"
	o = append(o, 0xa3, 0x43, 0x41, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CAD)))
	for za0017 := range z.CAD {
		o = msgp.AppendFloat64(o, z.CAD[za0017])
	}
	// string "KPW"
	o = append(o, 0xa3, 0x4b, 0x50, 0x57)
	o = msgp.AppendArrayHeader(o, uint32(len(z.KPW)))
	for za0018 := range z.KPW {
		o = msgp.AppendFloat64(o, z.KPW[za0018])
	}
	// string "KRW"
	o = append(o, 0xa3, 0x4b, 0x52, 0x57)
	o = msgp.AppendArrayHeader(o, uint32(len(z.KRW)))
	for za0019 := range z.KRW {
		o = msgp.AppendFloat64(o, z.KRW[za0019])
	}
	// string "MNT"
	o = append(o, 0xa3, 0x4d, 0x4e, 0x54)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MNT)))
	for za0020 := range z.MNT {
		o = msgp.AppendFloat64(o, z.MNT[za0020])
	}
	// string "TMT"
	o = append(o, 0xa3, 0x54, 0x4d, 0x54)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TMT)))
	for za0021 := range z.TMT {
		o = msgp.AppendFloat64(o, z.TMT[za0021])
	}
	// string "GEL"
	o = append(o, 0xa3, 0x47, 0x45, 0x4c)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GEL)))
	for za0022 := range z.GEL {
		o = msgp.AppendFloat64(o, z.GEL[za0022])
	}
	// string "GOLD"
	o = append(o, 0xa4, 0x47, 0x4f, 0x4c, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GOLD)))
	for za0023 := range z.GOLD {
		o = msgp.AppendFloat64(o, z.GOLD[za0023])
	}
	// string "AZN"
	o = append(o, 0xa3, 0x41, 0x5a, 0x4e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AZN)))
	for za0024 := range z.AZN {
		o = msgp.AppendFloat64(o, z.AZN[za0024])
	}
	// string "BHD"
	o = append(o, 0xa3, 0x42, 0x48, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BHD)))
	for za0025 := range z.BHD {
		o = msgp.AppendFloat64(o, z.BHD[za0025])
	}
	// string "AMD"
	o = append(o, 0xa3, 0x41, 0x4d, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AMD)))
	for za0026 := range z.AMD {
		o = msgp.AppendFloat64(o, z.AMD[za0026])
	}
	// string "BYN"
	o = append(o, 0xa3, 0x42, 0x59, 0x4e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BYN)))
	for za0027 := range z.BYN {
		o = msgp.AppendFloat64(o, z.BYN[za0027])
	}
	// string "BRL"
	o = append(o, 0xa3, 0x42, 0x52, 0x4c)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BRL)))
	for za0028 := range z.BRL {
		o = msgp.AppendFloat64(o, z.BRL[za0028])
	}
	// string "HUF"
	o = append(o, 0xa3, 0x48, 0x55, 0x46)
	o = msgp.AppendArrayHeader(o, uint32(len(z.HUF)))
	for za0029 := range z.HUF {
		o = msgp.AppendFloat64(o, z.HUF[za0029])
	}
	// string "HKD"
	o = append(o, 0xa3, 0x48, 0x4b, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.HKD)))
	for za0030 := range z.HKD {
		o = msgp.AppendFloat64(o, z.HKD[za0030])
	}
	// string "DKK"
	o = append(o, 0xa3, 0x44, 0x4b, 0x4b)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DKK)))
	for za0031 := range z.DKK {
		o = msgp.AppendFloat64(o, z.DKK[za0031])
	}
	// string "IRR"
	o = append(o, 0xa3, 0x49, 0x52, 0x52)
	o = msgp.AppendArrayHeader(o, uint32(len(z.IRR)))
	for za0032 := range z.IRR {
		o = msgp.AppendFloat64(o, z.IRR[za0032])
	}
	// string "KWD"
	o = append(o, 0xa3, 0x4b, 0x57, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.KWD)))
	for za0033 := range z.KWD {
		o = msgp.AppendFloat64(o, z.KWD[za0033])
	}
	// string "MYR"
	o = append(o, 0xa3, 0x4d, 0x59, 0x52)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MYR)))
	for za0034 := range z.MYR {
		o = msgp.AppendFloat64(o, z.MYR[za0034])
	}
	// string "MXN"
	o = append(o, 0xa3, 0x4d, 0x58, 0x4e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MXN)))
	for za0035 := range z.MXN {
		o = msgp.AppendFloat64(o, z.MXN[za0035])
	}
	// string "MDL"
	o = append(o, 0xa3, 0x4d, 0x44, 0x4c)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MDL)))
	for za0036 := range z.MDL {
		o = msgp.AppendFloat64(o, z.MDL[za0036])
	}
	// string "NOK"
	o = append(o, 0xa3, 0x4e, 0x4f, 0x4b)
	o = msgp.AppendArrayHeader(o, uint32(len(z.NOK)))
	for za0037 := range z.NOK {
		o = msgp.AppendFloat64(o, z.NOK[za0037])
	}
	// string "PLN"
	o = append(o, 0xa3, 0x50, 0x4c, 0x4e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PLN)))
	for za0038 := range z.PLN {
		o = msgp.AppendFloat64(o, z.PLN[za0038])
	}
	// string "SAR"
	o = append(o, 0xa3, 0x53, 0x41, 0x52)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SAR)))
	for za0039 := range z.SAR {
		o = msgp.AppendFloat64(o, z.SAR[za0039])
	}
	// string "XDR"
	o = append(o, 0xa3, 0x58, 0x44, 0x52)
	o = msgp.AppendArrayHeader(o, uint32(len(z.XDR)))
	for za0040 := range z.XDR {
		o = msgp.AppendFloat64(o, z.XDR[za0040])
	}
	// string "SGD"
	o = append(o, 0xa3, 0x53, 0x47, 0x44)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SGD)))
	for za0041 := range z.SGD {
		o = msgp.AppendFloat64(o, z.SGD[za0041])
	}
	// string "TJS"
	o = append(o, 0xa3, 0x54, 0x4a, 0x53)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TJS)))
	for za0042 := range z.TJS {
		o = msgp.AppendFloat64(o, z.TJS[za0042])
	}
	// string "CZK"
	o = append(o, 0xa3, 0x43, 0x5a, 0x4b)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CZK)))
	for za0043 := range z.CZK {
		o = msgp.AppendFloat64(o, z.CZK[za0043])
	}
	// string "SEK"
	o = append(o, 0xa3, 0x53, 0x45, 0x4b)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SEK)))
	for za0044 := range z.SEK {
		o = msgp.AppendFloat64(o, z.SEK[za0044])
	}
	// string "ZAR"
	o = append(o, 0xa3, 0x5a, 0x41, 0x52)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ZAR)))
	for za0045 := range z.ZAR {
		o = msgp.AppendFloat64(o, z.ZAR[za0045])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Data) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "USD":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "USD")
				return
			}
			if cap(z.USD) >= int(zb0002) {
				z.USD = (z.USD)[:zb0002]
			} else {
				z.USD = make([]float64, zb0002)
			}
			for za0001 := range z.USD {
				z.USD[za0001], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "USD", za0001)
					return
				}
			}
		case "EUR":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EUR")
				return
			}
			if cap(z.EUR) >= int(zb0003) {
				z.EUR = (z.EUR)[:zb0003]
			} else {
				z.EUR = make([]float64, zb0003)
			}
			for za0002 := range z.EUR {
				z.EUR[za0002], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EUR", za0002)
					return
				}
			}
		case "RUB":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RUB")
				return
			}
			if cap(z.RUB) >= int(zb0004) {
				z.RUB = (z.RUB)[:zb0004]
			} else {
				z.RUB = make([]float64, zb0004)
			}
			for za0003 := range z.RUB {
				z.RUB[za0003], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RUB", za0003)
					return
				}
			}
		case "KGS":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KGS")
				return
			}
			if cap(z.KGS) >= int(zb0005) {
				z.KGS = (z.KGS)[:zb0005]
			} else {
				z.KGS = make([]float64, zb0005)
			}
			for za0004 := range z.KGS {
				z.KGS[za0004], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KGS", za0004)
					return
				}
			}
		case "CNY":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CNY")
				return
			}
			if cap(z.CNY) >= int(zb0006) {
				z.CNY = (z.CNY)[:zb0006]
			} else {
				z.CNY = make([]float64, zb0006)
			}
			for za0005 := range z.CNY {
				z.CNY[za0005], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CNY", za0005)
					return
				}
			}
		case "GBP":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GBP")
				return
			}
			if cap(z.GBP) >= int(zb0007) {
				z.GBP = (z.GBP)[:zb0007]
			} else {
				z.GBP = make([]float64, zb0007)
			}
			for za0006 := range z.GBP {
				z.GBP[za0006], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GBP", za0006)
					return
				}
			}
		case "CHF":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CHF")
				return
			}
			if cap(z.CHF) >= int(zb0008) {
				z.CHF = (z.CHF)[:zb0008]
			} else {
				z.CHF = make([]float64, zb0008)
			}
			for za0007 := range z.CHF {
				z.CHF[za0007], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CHF", za0007)
					return
				}
			}
		case "UZS":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UZS")
				return
			}
			if cap(z.UZS) >= int(zb0009) {
				z.UZS = (z.UZS)[:zb0009]
			} else {
				z.UZS = make([]float64, zb0009)
			}
			for za0008 := range z.UZS {
				z.UZS[za0008], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UZS", za0008)
					return
				}
			}
		case "JPY":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "JPY")
				return
			}
			if cap(z.JPY) >= int(zb0010) {
				z.JPY = (z.JPY)[:zb0010]
			} else {
				z.JPY = make([]float64, zb0010)
			}
			for za0009 := range z.JPY {
				z.JPY[za0009], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "JPY", za0009)
					return
				}
			}
		case "AUD":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AUD")
				return
			}
			if cap(z.AUD) >= int(zb0011) {
				z.AUD = (z.AUD)[:zb0011]
			} else {
				z.AUD = make([]float64, zb0011)
			}
			for za0010 := range z.AUD {
				z.AUD[za0010], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AUD", za0010)
					return
				}
			}
		case "TRY":
			var zb0012 uint32
			zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TRY")
				return
			}
			if cap(z.TRY) >= int(zb0012) {
				z.TRY = (z.TRY)[:zb0012]
			} else {
				z.TRY = make([]float64, zb0012)
			}
			for za0011 := range z.TRY {
				z.TRY[za0011], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TRY", za0011)
					return
				}
			}
		case "AED":
			var zb0013 uint32
			zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AED")
				return
			}
			if cap(z.AED) >= int(zb0013) {
				z.AED = (z.AED)[:zb0013]
			} else {
				z.AED = make([]float64, zb0013)
			}
			for za0012 := range z.AED {
				z.AED[za0012], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AED", za0012)
					return
				}
			}
		case "UAH":
			var zb0014 uint32
			zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UAH")
				return
			}
			if cap(z.UAH) >= int(zb0014) {
				z.UAH = (z.UAH)[:zb0014]
			} else {
				z.UAH = make([]float64, zb0014)
			}
			for za0013 := range z.UAH {
				z.UAH[za0013], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UAH", za0013)
					return
				}
			}
		case "THB":
			var zb0015 uint32
			zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "THB")
				return
			}
			if cap(z.THB) >= int(zb0015) {
				z.THB = (z.THB)[:zb0015]
			} else {
				z.THB = make([]float64, zb0015)
			}
			for za0014 := range z.THB {
				z.THB[za0014], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "THB", za0014)
					return
				}
			}
		case "INR":
			var zb0016 uint32
			zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "INR")
				return
			}
			if cap(z.INR) >= int(zb0016) {
				z.INR = (z.INR)[:zb0016]
			} else {
				z.INR = make([]float64, zb0016)
			}
			for za0015 := range z.INR {
				z.INR[za0015], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "INR", za0015)
					return
				}
			}
		case "EGP":
			var zb0017 uint32
			zb0017, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EGP")
				return
			}
			if cap(z.EGP) >= int(zb0017) {
				z.EGP = (z.EGP)[:zb0017]
			} else {
				z.EGP = make([]float64, zb0017)
			}
			for za0016 := range z.EGP {
				z.EGP[za0016], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EGP", za0016)
					return
				}
			}
		case "CAD":
			var zb0018 uint32
			zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CAD")
				return
			}
			if cap(z.CAD) >= int(zb0018) {
				z.CAD = (z.CAD)[:zb0018]
			} else {
				z.CAD = make([]float64, zb0018)
			}
			for za0017 := range z.CAD {
				z.CAD[za0017], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CAD", za0017)
					return
				}
			}
		case "KPW":
			var zb0019 uint32
			zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KPW")
				return
			}
			if cap(z.KPW) >= int(zb0019) {
				z.KPW = (z.KPW)[:zb0019]
			} else {
				z.KPW = make([]float64, zb0019)
			}
			for za0018 := range z.KPW {
				z.KPW[za0018], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KPW", za0018)
					return
				}
			}
		case "KRW":
			var zb0020 uint32
			zb0020, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KRW")
				return
			}
			if cap(z.KRW) >= int(zb0020) {
				z.KRW = (z.KRW)[:zb0020]
			} else {
				z.KRW = make([]float64, zb0020)
			}
			for za0019 := range z.KRW {
				z.KRW[za0019], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KRW", za0019)
					return
				}
			}
		case "MNT":
			var zb0021 uint32
			zb0021, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MNT")
				return
			}
			if cap(z.MNT) >= int(zb0021) {
				z.MNT = (z.MNT)[:zb0021]
			} else {
				z.MNT = make([]float64, zb0021)
			}
			for za0020 := range z.MNT {
				z.MNT[za0020], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MNT", za0020)
					return
				}
			}
		case "TMT":
			var zb0022 uint32
			zb0022, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TMT")
				return
			}
			if cap(z.TMT) >= int(zb0022) {
				z.TMT = (z.TMT)[:zb0022]
			} else {
				z.TMT = make([]float64, zb0022)
			}
			for za0021 := range z.TMT {
				z.TMT[za0021], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TMT", za0021)
					return
				}
			}
		case "GEL":
			var zb0023 uint32
			zb0023, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GEL")
				return
			}
			if cap(z.GEL) >= int(zb0023) {
				z.GEL = (z.GEL)[:zb0023]
			} else {
				z.GEL = make([]float64, zb0023)
			}
			for za0022 := range z.GEL {
				z.GEL[za0022], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GEL", za0022)
					return
				}
			}
		case "GOLD":
			var zb0024 uint32
			zb0024, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GOLD")
				return
			}
			if cap(z.GOLD) >= int(zb0024) {
				z.GOLD = (z.GOLD)[:zb0024]
			} else {
				z.GOLD = make([]float64, zb0024)
			}
			for za0023 := range z.GOLD {
				z.GOLD[za0023], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GOLD", za0023)
					return
				}
			}
		case "AZN":
			var zb0025 uint32
			zb0025, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AZN")
				return
			}
			if cap(z.AZN) >= int(zb0025) {
				z.AZN = (z.AZN)[:zb0025]
			} else {
				z.AZN = make([]float64, zb0025)
			}
			for za0024 := range z.AZN {
				z.AZN[za0024], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AZN", za0024)
					return
				}
			}
		case "BHD":
			var zb0026 uint32
			zb0026, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BHD")
				return
			}
			if cap(z.BHD) >= int(zb0026) {
				z.BHD = (z.BHD)[:zb0026]
			} else {
				z.BHD = make([]float64, zb0026)
			}
			for za0025 := range z.BHD {
				z.BHD[za0025], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BHD", za0025)
					return
				}
			}
		case "AMD":
			var zb0027 uint32
			zb0027, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AMD")
				return
			}
			if cap(z.AMD) >= int(zb0027) {
				z.AMD = (z.AMD)[:zb0027]
			} else {
				z.AMD = make([]float64, zb0027)
			}
			for za0026 := range z.AMD {
				z.AMD[za0026], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AMD", za0026)
					return
				}
			}
		case "BYN":
			var zb0028 uint32
			zb0028, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BYN")
				return
			}
			if cap(z.BYN) >= int(zb0028) {
				z.BYN = (z.BYN)[:zb0028]
			} else {
				z.BYN = make([]float64, zb0028)
			}
			for za0027 := range z.BYN {
				z.BYN[za0027], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BYN", za0027)
					return
				}
			}
		case "BRL":
			var zb0029 uint32
			zb0029, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BRL")
				return
			}
			if cap(z.BRL) >= int(zb0029) {
				z.BRL = (z.BRL)[:zb0029]
			} else {
				z.BRL = make([]float64, zb0029)
			}
			for za0028 := range z.BRL {
				z.BRL[za0028], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BRL", za0028)
					return
				}
			}
		case "HUF":
			var zb0030 uint32
			zb0030, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HUF")
				return
			}
			if cap(z.HUF) >= int(zb0030) {
				z.HUF = (z.HUF)[:zb0030]
			} else {
				z.HUF = make([]float64, zb0030)
			}
			for za0029 := range z.HUF {
				z.HUF[za0029], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HUF", za0029)
					return
				}
			}
		case "HKD":
			var zb0031 uint32
			zb0031, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HKD")
				return
			}
			if cap(z.HKD) >= int(zb0031) {
				z.HKD = (z.HKD)[:zb0031]
			} else {
				z.HKD = make([]float64, zb0031)
			}
			for za0030 := range z.HKD {
				z.HKD[za0030], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HKD", za0030)
					return
				}
			}
		case "DKK":
			var zb0032 uint32
			zb0032, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DKK")
				return
			}
			if cap(z.DKK) >= int(zb0032) {
				z.DKK = (z.DKK)[:zb0032]
			} else {
				z.DKK = make([]float64, zb0032)
			}
			for za0031 := range z.DKK {
				z.DKK[za0031], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DKK", za0031)
					return
				}
			}
		case "IRR":
			var zb0033 uint32
			zb0033, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IRR")
				return
			}
			if cap(z.IRR) >= int(zb0033) {
				z.IRR = (z.IRR)[:zb0033]
			} else {
				z.IRR = make([]float64, zb0033)
			}
			for za0032 := range z.IRR {
				z.IRR[za0032], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IRR", za0032)
					return
				}
			}
		case "KWD":
			var zb0034 uint32
			zb0034, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KWD")
				return
			}
			if cap(z.KWD) >= int(zb0034) {
				z.KWD = (z.KWD)[:zb0034]
			} else {
				z.KWD = make([]float64, zb0034)
			}
			for za0033 := range z.KWD {
				z.KWD[za0033], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KWD", za0033)
					return
				}
			}
		case "MYR":
			var zb0035 uint32
			zb0035, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MYR")
				return
			}
			if cap(z.MYR) >= int(zb0035) {
				z.MYR = (z.MYR)[:zb0035]
			} else {
				z.MYR = make([]float64, zb0035)
			}
			for za0034 := range z.MYR {
				z.MYR[za0034], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MYR", za0034)
					return
				}
			}
		case "MXN":
			var zb0036 uint32
			zb0036, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MXN")
				return
			}
			if cap(z.MXN) >= int(zb0036) {
				z.MXN = (z.MXN)[:zb0036]
			} else {
				z.MXN = make([]float64, zb0036)
			}
			for za0035 := range z.MXN {
				z.MXN[za0035], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MXN", za0035)
					return
				}
			}
		case "MDL":
			var zb0037 uint32
			zb0037, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MDL")
				return
			}
			if cap(z.MDL) >= int(zb0037) {
				z.MDL = (z.MDL)[:zb0037]
			} else {
				z.MDL = make([]float64, zb0037)
			}
			for za0036 := range z.MDL {
				z.MDL[za0036], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MDL", za0036)
					return
				}
			}
		case "NOK":
			var zb0038 uint32
			zb0038, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NOK")
				return
			}
			if cap(z.NOK) >= int(zb0038) {
				z.NOK = (z.NOK)[:zb0038]
			} else {
				z.NOK = make([]float64, zb0038)
			}
			for za0037 := range z.NOK {
				z.NOK[za0037], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NOK", za0037)
					return
				}
			}
		case "PLN":
			var zb0039 uint32
			zb0039, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PLN")
				return
			}
			if cap(z.PLN) >= int(zb0039) {
				z.PLN = (z.PLN)[:zb0039]
			} else {
				z.PLN = make([]float64, zb0039)
			}
			for za0038 := range z.PLN {
				z.PLN[za0038], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PLN", za0038)
					return
				}
			}
		case "SAR":
			var zb0040 uint32
			zb0040, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SAR")
				return
			}
			if cap(z.SAR) >= int(zb0040) {
				z.SAR = (z.SAR)[:zb0040]
			} else {
				z.SAR = make([]float64, zb0040)
			}
			for za0039 := range z.SAR {
				z.SAR[za0039], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SAR", za0039)
					return
				}
			}
		case "XDR":
			var zb0041 uint32
			zb0041, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "XDR")
				return
			}
			if cap(z.XDR) >= int(zb0041) {
				z.XDR = (z.XDR)[:zb0041]
			} else {
				z.XDR = make([]float64, zb0041)
			}
			for za0040 := range z.XDR {
				z.XDR[za0040], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "XDR", za0040)
					return
				}
			}
		case "SGD":
			var zb0042 uint32
			zb0042, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SGD")
				return
			}
			if cap(z.SGD) >= int(zb0042) {
				z.SGD = (z.SGD)[:zb0042]
			} else {
				z.SGD = make([]float64, zb0042)
			}
			for za0041 := range z.SGD {
				z.SGD[za0041], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SGD", za0041)
					return
				}
			}
		case "TJS":
			var zb0043 uint32
			zb0043, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TJS")
				return
			}
			if cap(z.TJS) >= int(zb0043) {
				z.TJS = (z.TJS)[:zb0043]
			} else {
				z.TJS = make([]float64, zb0043)
			}
			for za0042 := range z.TJS {
				z.TJS[za0042], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TJS", za0042)
					return
				}
			}
		case "CZK":
			var zb0044 uint32
			zb0044, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CZK")
				return
			}
			if cap(z.CZK) >= int(zb0044) {
				z.CZK = (z.CZK)[:zb0044]
			} else {
				z.CZK = make([]float64, zb0044)
			}
			for za0043 := range z.CZK {
				z.CZK[za0043], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CZK", za0043)
					return
				}
			}
		case "SEK":
			var zb0045 uint32
			zb0045, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SEK")
				return
			}
			if cap(z.SEK) >= int(zb0045) {
				z.SEK = (z.SEK)[:zb0045]
			} else {
				z.SEK = make([]float64, zb0045)
			}
			for za0044 := range z.SEK {
				z.SEK[za0044], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SEK", za0044)
					return
				}
			}
		case "ZAR":
			var zb0046 uint32
			zb0046, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ZAR")
				return
			}
			if cap(z.ZAR) >= int(zb0046) {
				z.ZAR = (z.ZAR)[:zb0046]
			} else {
				z.ZAR = make([]float64, zb0046)
			}
			for za0045 := range z.ZAR {
				z.ZAR[za0045], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ZAR", za0045)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Data) Msgsize() (s int) {
	s = 3 + 4 + msgp.ArrayHeaderSize + (len(z.USD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.EUR) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.RUB) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.KGS) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.CNY) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.GBP) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.CHF) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.UZS) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.JPY) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.AUD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.TRY) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.AED) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.UAH) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.THB) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.INR) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.EGP) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.CAD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.KPW) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.KRW) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.MNT) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.TMT) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.GEL) * (msgp.Float64Size)) + 5 + msgp.ArrayHeaderSize + (len(z.GOLD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.AZN) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.BHD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.AMD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.BYN) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.BRL) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.HUF) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.HKD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.DKK) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.IRR) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.KWD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.MYR) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.MXN) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.MDL) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.NOK) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.PLN) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.SAR) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.XDR) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.SGD) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.TJS) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.CZK) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.SEK) * (msgp.Float64Size)) + 4 + msgp.ArrayHeaderSize + (len(z.ZAR) * (msgp.Float64Size))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Map) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Lat":
			z.Lat, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Lat")
				return
			}
		case "Lng":
			z.Lng, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Lng")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Map) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Lat"
	err = en.Append(0x82, 0xa3, 0x4c, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Lat)
	if err != nil {
		err = msgp.WrapError(err, "Lat")
		return
	}
	// write "Lng"
	err = en.Append(0xa3, 0x4c, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.Lng)
	if err != nil {
		err = msgp.WrapError(err, "Lng")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Map) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Lat"
	o = append(o, 0x82, 0xa3, 0x4c, 0x61, 0x74)
	o = msgp.AppendString(o, z.Lat)
	// string "Lng"
	o = append(o, 0xa3, 0x4c, 0x6e, 0x67)
	o = msgp.AppendString(o, z.Lng)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Map) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Lat":
			z.Lat, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lat")
				return
			}
		case "Lng":
			z.Lng, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lng")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Map) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.Lat) + 4 + msgp.StringPrefixSize + len(z.Lng)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Punkt) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "City":
			z.City, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "City")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Weight":
			z.Weight, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Weight")
				return
			}
		case "Wholesale":
			z.Wholesale, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Wholesale")
				return
			}
		case "WholesaleText":
			z.WholesaleText, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WholesaleText")
				return
			}
		case "Mainaddress":
			z.Mainaddress, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Mainaddress")
				return
			}
		case "Gruppa":
			z.Gruppa, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Gruppa")
				return
			}
		case "Address":
			z.Address, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "Phone":
			z.Phone, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Phone")
				return
			}
		case "Phones":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Phones")
				return
			}
			if cap(z.Phones) >= int(zb0002) {
				z.Phones = (z.Phones)[:zb0002]
			} else {
				z.Phones = make([]string, zb0002)
			}
			for za0001 := range z.Phones {
				z.Phones[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Phones", za0001)
					return
				}
			}
		case "Date":
			z.Date, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Bank":
			z.Bank, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Bank")
				return
			}
		case "Data":
			err = z.Data.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "Lat":
			z.Lat, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Lat")
				return
			}
		case "Lng":
			z.Lng, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Lng")
				return
			}
		case "Gray":
			z.Gray, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Gray")
				return
			}
		case "Actual":
			z.Actual, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Actual")
				return
			}
		case "ActualTime":
			z.ActualTime, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ActualTime")
				return
			}
		case "Workmodes":
			err = z.Workmodes.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Workmodes")
				return
			}
		case "Workattr":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Workattr")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Workattr")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Nonstop":
					z.Workattr.Nonstop, err = dc.ReadBool()
					if err != nil {
						err = msgp.WrapError(err, "Workattr", "Nonstop")
						return
					}
				case "Closed":
					z.Workattr.Closed, err = dc.ReadBool()
					if err != nil {
						err = msgp.WrapError(err, "Workattr", "Closed")
						return
					}
				case "Worknow":
					z.Workattr.Worknow, err = dc.ReadBool()
					if err != nil {
						err = msgp.WrapError(err, "Workattr", "Worknow")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Workattr")
						return
					}
				}
			}
		case "Map":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Map")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Map")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Lat":
					z.Map.Lat, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Map", "Lat")
						return
					}
				case "Lng":
					z.Map.Lng, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Map", "Lng")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Map")
						return
					}
				}
			}
		case "Mainsort":
			z.Mainsort, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Mainsort")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Punkt) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 23
	// write "ID"
	err = en.Append(0xde, 0x0, 0x17, 0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "City"
	err = en.Append(0xa4, 0x43, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.City)
	if err != nil {
		err = msgp.WrapError(err, "City")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "Weight"
	err = en.Append(0xa6, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Weight)
	if err != nil {
		err = msgp.WrapError(err, "Weight")
		return
	}
	// write "Wholesale"
	err = en.Append(0xa9, 0x57, 0x68, 0x6f, 0x6c, 0x65, 0x73, 0x61, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Wholesale)
	if err != nil {
		err = msgp.WrapError(err, "Wholesale")
		return
	}
	// write "WholesaleText"
	err = en.Append(0xad, 0x57, 0x68, 0x6f, 0x6c, 0x65, 0x73, 0x61, 0x6c, 0x65, 0x54, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.WholesaleText)
	if err != nil {
		err = msgp.WrapError(err, "WholesaleText")
		return
	}
	// write "Mainaddress"
	err = en.Append(0xab, 0x4d, 0x61, 0x69, 0x6e, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Mainaddress)
	if err != nil {
		err = msgp.WrapError(err, "Mainaddress")
		return
	}
	// write "Gruppa"
	err = en.Append(0xa6, 0x47, 0x72, 0x75, 0x70, 0x70, 0x61)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Gruppa)
	if err != nil {
		err = msgp.WrapError(err, "Gruppa")
		return
	}
	// write "Address"
	err = en.Append(0xa7, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.Address)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	// write "Phone"
	err = en.Append(0xa5, 0x50, 0x68, 0x6f, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Phone)
	if err != nil {
		err = msgp.WrapError(err, "Phone")
		return
	}
	// write "Phones"
	err = en.Append(0xa6, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Phones)))
	if err != nil {
		err = msgp.WrapError(err, "Phones")
		return
	}
	for za0001 := range z.Phones {
		err = en.WriteString(z.Phones[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Phones", za0001)
			return
		}
	}
	// write "Date"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Date)
	if err != nil {
		err = msgp.WrapError(err, "Date")
		return
	}
	// write "Bank"
	err = en.Append(0xa4, 0x42, 0x61, 0x6e, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Bank)
	if err != nil {
		err = msgp.WrapError(err, "Bank")
		return
	}
	// write "Data"
	err = en.Append(0xa4, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = z.Data.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// write "Lat"
	err = en.Append(0xa3, 0x4c, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Lat)
	if err != nil {
		err = msgp.WrapError(err, "Lat")
		return
	}
	// write "Lng"
	err = en.Append(0xa3, 0x4c, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.Lng)
	if err != nil {
		err = msgp.WrapError(err, "Lng")
		return
	}
	// write "Gray"
	err = en.Append(0xa4, 0x47, 0x72, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Gray)
	if err != nil {
		err = msgp.WrapError(err, "Gray")
		return
	}
	// write "Actual"
	err = en.Append(0xa6, 0x41, 0x63, 0x74, 0x75, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Actual)
	if err != nil {
		err = msgp.WrapError(err, "Actual")
		return
	}
	// write "ActualTime"
	err = en.Append(0xaa, 0x41, 0x63, 0x74, 0x75, 0x61, 0x6c, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ActualTime)
	if err != nil {
		err = msgp.WrapError(err, "ActualTime")
		return
	}
	// write "Workmodes"
	err = en.Append(0xa9, 0x57, 0x6f, 0x72, 0x6b, 0x6d, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	err = z.Workmodes.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Workmodes")
		return
	}
	// write "Workattr"
	// map header, size 3
	// write "Nonstop"
	err = en.Append(0xa8, 0x57, 0x6f, 0x72, 0x6b, 0x61, 0x74, 0x74, 0x72, 0x83, 0xa7, 0x4e, 0x6f, 0x6e, 0x73, 0x74, 0x6f, 0x70)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Workattr.Nonstop)
	if err != nil {
		err = msgp.WrapError(err, "Workattr", "Nonstop")
		return
	}
	// write "Closed"
	err = en.Append(0xa6, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Workattr.Closed)
	if err != nil {
		err = msgp.WrapError(err, "Workattr", "Closed")
		return
	}
	// write "Worknow"
	err = en.Append(0xa7, 0x57, 0x6f, 0x72, 0x6b, 0x6e, 0x6f, 0x77)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Workattr.Worknow)
	if err != nil {
		err = msgp.WrapError(err, "Workattr", "Worknow")
		return
	}
	// write "Map"
	// map header, size 2
	// write "Lat"
	err = en.Append(0xa3, 0x4d, 0x61, 0x70, 0x82, 0xa3, 0x4c, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Map.Lat)
	if err != nil {
		err = msgp.WrapError(err, "Map", "Lat")
		return
	}
	// write "Lng"
	err = en.Append(0xa3, 0x4c, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.Map.Lng)
	if err != nil {
		err = msgp.WrapError(err, "Map", "Lng")
		return
	}
	// write "Mainsort"
	err = en.Append(0xa8, 0x4d, 0x61, 0x69, 0x6e, 0x73, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Mainsort)
	if err != nil {
		err = msgp.WrapError(err, "Mainsort")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Punkt) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 23
	// string "ID"
	o = append(o, 0xde, 0x0, 0x17, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "City"
	o = append(o, 0xa4, 0x43, 0x69, 0x74, 0x79)
	o = msgp.AppendString(o, z.City)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "Weight"
	o = append(o, 0xa6, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendString(o, z.Weight)
	// string "Wholesale"
	o = append(o, 0xa9, 0x57, 0x68, 0x6f, 0x6c, 0x65, 0x73, 0x61, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.Wholesale)
	// string "WholesaleText"
	o = append(o, 0xad, 0x57, 0x68, 0x6f, 0x6c, 0x65, 0x73, 0x61, 0x6c, 0x65, 0x54, 0x65, 0x78, 0x74)
	o = msgp.AppendString(o, z.WholesaleText)
	// string "Mainaddress"
	o = append(o, 0xab, 0x4d, 0x61, 0x69, 0x6e, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	o = msgp.AppendString(o, z.Mainaddress)
	// string "Gruppa"
	o = append(o, 0xa6, 0x47, 0x72, 0x75, 0x70, 0x70, 0x61)
	o = msgp.AppendInt(o, z.Gruppa)
	// string "Address"
	o = append(o, 0xa7, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	o = msgp.AppendString(o, z.Address)
	// string "Phone"
	o = append(o, 0xa5, 0x50, 0x68, 0x6f, 0x6e, 0x65)
	o = msgp.AppendString(o, z.Phone)
	// string "Phones"
	o = append(o, 0xa6, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Phones)))
	for za0001 := range z.Phones {
		o = msgp.AppendString(o, z.Phones[za0001])
	}
	// string "Date"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x65)
	o = msgp.AppendInt(o, z.Date)
	// string "Bank"
	o = append(o, 0xa4, 0x42, 0x61, 0x6e, 0x6b)
	o = msgp.AppendInt(o, z.Bank)
	// string "Data"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x61)
	o, err = z.Data.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data")
		return
	}
	// string "Lat"
	o = append(o, 0xa3, 0x4c, 0x61, 0x74)
	o = msgp.AppendString(o, z.Lat)
	// string "Lng"
	o = append(o, 0xa3, 0x4c, 0x6e, 0x67)
	o = msgp.AppendString(o, z.Lng)
	// string "Gray"
	o = append(o, 0xa4, 0x47, 0x72, 0x61, 0x79)
	o = msgp.AppendBool(o, z.Gray)
	// string "Actual"
	o = append(o, 0xa6, 0x41, 0x63, 0x74, 0x75, 0x61, 0x6c)
	o = msgp.AppendBool(o, z.Actual)
	// string "ActualTime"
	o = append(o, 0xaa, 0x41, 0x63, 0x74, 0x75, 0x61, 0x6c, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.ActualTime)
	// string "Workmodes"
	o = append(o, 0xa9, 0x57, 0x6f, 0x72, 0x6b, 0x6d, 0x6f, 0x64, 0x65, 0x73)
	o, err = z.Workmodes.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Workmodes")
		return
	}
	// string "Workattr"
	// map header, size 3
	// string "Nonstop"
	o = append(o, 0xa8, 0x57, 0x6f, 0x72, 0x6b, 0x61, 0x74, 0x74, 0x72, 0x83, 0xa7, 0x4e, 0x6f, 0x6e, 0x73, 0x74, 0x6f, 0x70)
	o = msgp.AppendBool(o, z.Workattr.Nonstop)
	// string "Closed"
	o = append(o, 0xa6, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Workattr.Closed)
	// string "Worknow"
	o = append(o, 0xa7, 0x57, 0x6f, 0x72, 0x6b, 0x6e, 0x6f, 0x77)
	o = msgp.AppendBool(o, z.Workattr.Worknow)
	// string "Map"
	// map header, size 2
	// string "Lat"
	o = append(o, 0xa3, 0x4d, 0x61, 0x70, 0x82, 0xa3, 0x4c, 0x61, 0x74)
	o = msgp.AppendString(o, z.Map.Lat)
	// string "Lng"
	o = append(o, 0xa3, 0x4c, 0x6e, 0x67)
	o = msgp.AppendString(o, z.Map.Lng)
	// string "Mainsort"
	o = append(o, 0xa8, 0x4d, 0x61, 0x69, 0x6e, 0x73, 0x6f, 0x72, 0x74)
	o = msgp.AppendInt(o, z.Mainsort)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Punkt) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "City":
			z.City, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "City")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Weight":
			z.Weight, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Weight")
				return
			}
		case "Wholesale":
			z.Wholesale, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Wholesale")
				return
			}
		case "WholesaleText":
			z.WholesaleText, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WholesaleText")
				return
			}
		case "Mainaddress":
			z.Mainaddress, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mainaddress")
				return
			}
		case "Gruppa":
			z.Gruppa, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Gruppa")
				return
			}
		case "Address":
			z.Address, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Address")
				return
			}
		case "Phone":
			z.Phone, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Phone")
				return
			}
		case "Phones":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Phones")
				return
			}
			if cap(z.Phones) >= int(zb0002) {
				z.Phones = (z.Phones)[:zb0002]
			} else {
				z.Phones = make([]string, zb0002)
			}
			for za0001 := range z.Phones {
				z.Phones[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Phones", za0001)
					return
				}
			}
		case "Date":
			z.Date, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Bank":
			z.Bank, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bank")
				return
			}
		case "Data":
			bts, err = z.Data.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		case "Lat":
			z.Lat, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lat")
				return
			}
		case "Lng":
			z.Lng, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lng")
				return
			}
		case "Gray":
			z.Gray, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Gray")
				return
			}
		case "Actual":
			z.Actual, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Actual")
				return
			}
		case "ActualTime":
			z.ActualTime, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActualTime")
				return
			}
		case "Workmodes":
			bts, err = z.Workmodes.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Workmodes")
				return
			}
		case "Workattr":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Workattr")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Workattr")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Nonstop":
					z.Workattr.Nonstop, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Workattr", "Nonstop")
						return
					}
				case "Closed":
					z.Workattr.Closed, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Workattr", "Closed")
						return
					}
				case "Worknow":
					z.Workattr.Worknow, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Workattr", "Worknow")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Workattr")
						return
					}
				}
			}
		case "Map":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Map")
				return
			}
			for zb0004 > 0 {
				zb0004--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Map")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Lat":
					z.Map.Lat, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Map", "Lat")
						return
					}
				case "Lng":
					z.Map.Lng, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Map", "Lng")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Map")
						return
					}
				}
			}
		case "Mainsort":
			z.Mainsort, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mainsort")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Punkt) Msgsize() (s int) {
	s = 3 + 3 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.City) + 5 + msgp.StringPrefixSize + len(z.Name) + 7 + msgp.StringPrefixSize + len(z.Weight) + 10 + msgp.BoolSize + 14 + msgp.StringPrefixSize + len(z.WholesaleText) + 12 + msgp.StringPrefixSize + len(z.Mainaddress) + 7 + msgp.IntSize + 8 + msgp.StringPrefixSize + len(z.Address) + 6 + msgp.StringPrefixSize + len(z.Phone) + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Phones {
		s += msgp.StringPrefixSize + len(z.Phones[za0001])
	}
	s += 5 + msgp.IntSize + 5 + msgp.IntSize + 5 + z.Data.Msgsize() + 4 + msgp.StringPrefixSize + len(z.Lat) + 4 + msgp.StringPrefixSize + len(z.Lng) + 5 + msgp.BoolSize + 7 + msgp.BoolSize + 11 + msgp.IntSize + 10 + z.Workmodes.Msgsize() + 9 + 1 + 8 + msgp.BoolSize + 7 + msgp.BoolSize + 8 + msgp.BoolSize + 4 + 1 + 4 + msgp.StringPrefixSize + len(z.Map.Lat) + 4 + msgp.StringPrefixSize + len(z.Map.Lng) + 9 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Workattr) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Nonstop":
			z.Nonstop, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Nonstop")
				return
			}
		case "Closed":
			z.Closed, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Closed")
				return
			}
		case "Worknow":
			z.Worknow, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Worknow")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Workattr) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Nonstop"
	err = en.Append(0x83, 0xa7, 0x4e, 0x6f, 0x6e, 0x73, 0x74, 0x6f, 0x70)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Nonstop)
	if err != nil {
		err = msgp.WrapError(err, "Nonstop")
		return
	}
	// write "Closed"
	err = en.Append(0xa6, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Closed)
	if err != nil {
		err = msgp.WrapError(err, "Closed")
		return
	}
	// write "Worknow"
	err = en.Append(0xa7, 0x57, 0x6f, 0x72, 0x6b, 0x6e, 0x6f, 0x77)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Worknow)
	if err != nil {
		err = msgp.WrapError(err, "Worknow")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Workattr) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Nonstop"
	o = append(o, 0x83, 0xa7, 0x4e, 0x6f, 0x6e, 0x73, 0x74, 0x6f, 0x70)
	o = msgp.AppendBool(o, z.Nonstop)
	// string "Closed"
	o = append(o, 0xa6, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Closed)
	// string "Worknow"
	o = append(o, 0xa7, 0x57, 0x6f, 0x72, 0x6b, 0x6e, 0x6f, 0x77)
	o = msgp.AppendBool(o, z.Worknow)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Workattr) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Nonstop":
			z.Nonstop, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nonstop")
				return
			}
		case "Closed":
			z.Closed, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Closed")
				return
			}
		case "Worknow":
			z.Worknow, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Worknow")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Workattr) Msgsize() (s int) {
	s = 1 + 8 + msgp.BoolSize + 7 + msgp.BoolSize + 8 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Workmodes) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Mon":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Mon")
				return
			}
			if cap(z.Mon) >= int(zb0002) {
				z.Mon = (z.Mon)[:zb0002]
			} else {
				z.Mon = make([]string, zb0002)
			}
			for za0001 := range z.Mon {
				z.Mon[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Mon", za0001)
					return
				}
			}
		case "Tue":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Tue")
				return
			}
			if cap(z.Tue) >= int(zb0003) {
				z.Tue = (z.Tue)[:zb0003]
			} else {
				z.Tue = make([]string, zb0003)
			}
			for za0002 := range z.Tue {
				z.Tue[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Tue", za0002)
					return
				}
			}
		case "Wed":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Wed")
				return
			}
			if cap(z.Wed) >= int(zb0004) {
				z.Wed = (z.Wed)[:zb0004]
			} else {
				z.Wed = make([]string, zb0004)
			}
			for za0003 := range z.Wed {
				z.Wed[za0003], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Wed", za0003)
					return
				}
			}
		case "Thu":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Thu")
				return
			}
			if cap(z.Thu) >= int(zb0005) {
				z.Thu = (z.Thu)[:zb0005]
			} else {
				z.Thu = make([]string, zb0005)
			}
			for za0004 := range z.Thu {
				z.Thu[za0004], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Thu", za0004)
					return
				}
			}
		case "Fri":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Fri")
				return
			}
			if cap(z.Fri) >= int(zb0006) {
				z.Fri = (z.Fri)[:zb0006]
			} else {
				z.Fri = make([]string, zb0006)
			}
			for za0005 := range z.Fri {
				z.Fri[za0005], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Fri", za0005)
					return
				}
			}
		case "Sat":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Sat")
				return
			}
			if cap(z.Sat) >= int(zb0007) {
				z.Sat = (z.Sat)[:zb0007]
			} else {
				z.Sat = make([]string, zb0007)
			}
			for za0006 := range z.Sat {
				z.Sat[za0006], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Sat", za0006)
					return
				}
			}
		case "Sun":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Sun")
				return
			}
			if cap(z.Sun) >= int(zb0008) {
				z.Sun = (z.Sun)[:zb0008]
			} else {
				z.Sun = make([]string, zb0008)
			}
			for za0007 := range z.Sun {
				z.Sun[za0007], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Sun", za0007)
					return
				}
			}
		case "Holyday":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Holyday")
				return
			}
			if cap(z.Holyday) >= int(zb0009) {
				z.Holyday = (z.Holyday)[:zb0009]
			} else {
				z.Holyday = make([]string, zb0009)
			}
			for za0008 := range z.Holyday {
				z.Holyday[za0008], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Holyday", za0008)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Workmodes) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "Mon"
	err = en.Append(0x88, 0xa3, 0x4d, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Mon)))
	if err != nil {
		err = msgp.WrapError(err, "Mon")
		return
	}
	for za0001 := range z.Mon {
		err = en.WriteString(z.Mon[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Mon", za0001)
			return
		}
	}
	// write "Tue"
	err = en.Append(0xa3, 0x54, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Tue)))
	if err != nil {
		err = msgp.WrapError(err, "Tue")
		return
	}
	for za0002 := range z.Tue {
		err = en.WriteString(z.Tue[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Tue", za0002)
			return
		}
	}
	// write "Wed"
	err = en.Append(0xa3, 0x57, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Wed)))
	if err != nil {
		err = msgp.WrapError(err, "Wed")
		return
	}
	for za0003 := range z.Wed {
		err = en.WriteString(z.Wed[za0003])
		if err != nil {
			err = msgp.WrapError(err, "Wed", za0003)
			return
		}
	}
	// write "Thu"
	err = en.Append(0xa3, 0x54, 0x68, 0x75)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Thu)))
	if err != nil {
		err = msgp.WrapError(err, "Thu")
		return
	}
	for za0004 := range z.Thu {
		err = en.WriteString(z.Thu[za0004])
		if err != nil {
			err = msgp.WrapError(err, "Thu", za0004)
			return
		}
	}
	// write "Fri"
	err = en.Append(0xa3, 0x46, 0x72, 0x69)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Fri)))
	if err != nil {
		err = msgp.WrapError(err, "Fri")
		return
	}
	for za0005 := range z.Fri {
		err = en.WriteString(z.Fri[za0005])
		if err != nil {
			err = msgp.WrapError(err, "Fri", za0005)
			return
		}
	}
	// write "Sat"
	err = en.Append(0xa3, 0x53, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Sat)))
	if err != nil {
		err = msgp.WrapError(err, "Sat")
		return
	}
	for za0006 := range z.Sat {
		err = en.WriteString(z.Sat[za0006])
		if err != nil {
			err = msgp.WrapError(err, "Sat", za0006)
			return
		}
	}
	// write "Sun"
	err = en.Append(0xa3, 0x53, 0x75, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Sun)))
	if err != nil {
		err = msgp.WrapError(err, "Sun")
		return
	}
	for za0007 := range z.Sun {
		err = en.WriteString(z.Sun[za0007])
		if err != nil {
			err = msgp.WrapError(err, "Sun", za0007)
			return
		}
	}
	// write "Holyday"
	err = en.Append(0xa7, 0x48, 0x6f, 0x6c, 0x79, 0x64, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Holyday)))
	if err != nil {
		err = msgp.WrapError(err, "Holyday")
		return
	}
	for za0008 := range z.Holyday {
		err = en.WriteString(z.Holyday[za0008])
		if err != nil {
			err = msgp.WrapError(err, "Holyday", za0008)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Workmodes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "Mon"
	o = append(o, 0x88, 0xa3, 0x4d, 0x6f, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Mon)))
	for za0001 := range z.Mon {
		o = msgp.AppendString(o, z.Mon[za0001])
	}
	// string "Tue"
	o = append(o, 0xa3, 0x54, 0x75, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Tue)))
	for za0002 := range z.Tue {
		o = msgp.AppendString(o, z.Tue[za0002])
	}
	// string "Wed"
	o = append(o, 0xa3, 0x57, 0x65, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Wed)))
	for za0003 := range z.Wed {
		o = msgp.AppendString(o, z.Wed[za0003])
	}
	// string "Thu"
	o = append(o, 0xa3, 0x54, 0x68, 0x75)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Thu)))
	for za0004 := range z.Thu {
		o = msgp.AppendString(o, z.Thu[za0004])
	}
	// string "Fri"
	o = append(o, 0xa3, 0x46, 0x72, 0x69)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Fri)))
	for za0005 := range z.Fri {
		o = msgp.AppendString(o, z.Fri[za0005])
	}
	// string "Sat"
	o = append(o, 0xa3, 0x53, 0x61, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Sat)))
	for za0006 := range z.Sat {
		o = msgp.AppendString(o, z.Sat[za0006])
	}
	// string "Sun"
	o = append(o, 0xa3, 0x53, 0x75, 0x6e)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Sun)))
	for za0007 := range z.Sun {
		o = msgp.AppendString(o, z.Sun[za0007])
	}
	// string "Holyday"
	o = append(o, 0xa7, 0x48, 0x6f, 0x6c, 0x79, 0x64, 0x61, 0x79)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Holyday)))
	for za0008 := range z.Holyday {
		o = msgp.AppendString(o, z.Holyday[za0008])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Workmodes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Mon":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mon")
				return
			}
			if cap(z.Mon) >= int(zb0002) {
				z.Mon = (z.Mon)[:zb0002]
			} else {
				z.Mon = make([]string, zb0002)
			}
			for za0001 := range z.Mon {
				z.Mon[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mon", za0001)
					return
				}
			}
		case "Tue":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tue")
				return
			}
			if cap(z.Tue) >= int(zb0003) {
				z.Tue = (z.Tue)[:zb0003]
			} else {
				z.Tue = make([]string, zb0003)
			}
			for za0002 := range z.Tue {
				z.Tue[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Tue", za0002)
					return
				}
			}
		case "Wed":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Wed")
				return
			}
			if cap(z.Wed) >= int(zb0004) {
				z.Wed = (z.Wed)[:zb0004]
			} else {
				z.Wed = make([]string, zb0004)
			}
			for za0003 := range z.Wed {
				z.Wed[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Wed", za0003)
					return
				}
			}
		case "Thu":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Thu")
				return
			}
			if cap(z.Thu) >= int(zb0005) {
				z.Thu = (z.Thu)[:zb0005]
			} else {
				z.Thu = make([]string, zb0005)
			}
			for za0004 := range z.Thu {
				z.Thu[za0004], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Thu", za0004)
					return
				}
			}
		case "Fri":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Fri")
				return
			}
			if cap(z.Fri) >= int(zb0006) {
				z.Fri = (z.Fri)[:zb0006]
			} else {
				z.Fri = make([]string, zb0006)
			}
			for za0005 := range z.Fri {
				z.Fri[za0005], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Fri", za0005)
					return
				}
			}
		case "Sat":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sat")
				return
			}
			if cap(z.Sat) >= int(zb0007) {
				z.Sat = (z.Sat)[:zb0007]
			} else {
				z.Sat = make([]string, zb0007)
			}
			for za0006 := range z.Sat {
				z.Sat[za0006], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sat", za0006)
					return
				}
			}
		case "Sun":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sun")
				return
			}
			if cap(z.Sun) >= int(zb0008) {
				z.Sun = (z.Sun)[:zb0008]
			} else {
				z.Sun = make([]string, zb0008)
			}
			for za0007 := range z.Sun {
				z.Sun[za0007], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sun", za0007)
					return
				}
			}
		case "Holyday":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Holyday")
				return
			}
			if cap(z.Holyday) >= int(zb0009) {
				z.Holyday = (z.Holyday)[:zb0009]
			} else {
				z.Holyday = make([]string, zb0009)
			}
			for za0008 := range z.Holyday {
				z.Holyday[za0008], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Holyday", za0008)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Workmodes) Msgsize() (s int) {
	s = 1 + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.Mon {
		s += msgp.StringPrefixSize + len(z.Mon[za0001])
	}
	s += 4 + msgp.ArrayHeaderSize
	for za0002 := range z.Tue {
		s += msgp.StringPrefixSize + len(z.Tue[za0002])
	}
	s += 4 + msgp.ArrayHeaderSize
	for za0003 := range z.Wed {
		s += msgp.StringPrefixSize + len(z.Wed[za0003])
	}
	s += 4 + msgp.ArrayHeaderSize
	for za0004 := range z.Thu {
		s += msgp.StringPrefixSize + len(z.Thu[za0004])
	}
	s += 4 + msgp.ArrayHeaderSize
	for za0005 := range z.Fri {
		s += msgp.StringPrefixSize + len(z.Fri[za0005])
	}
	s += 4 + msgp.ArrayHeaderSize
	for za0006 := range z.Sat {
		s += msgp.StringPrefixSize + len(z.Sat[za0006])
	}
	s += 4 + msgp.ArrayHeaderSize
	for za0007 := range z.Sun {
		s += msgp.StringPrefixSize + len(z.Sun[za0007])
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0008 := range z.Holyday {
		s += msgp.StringPrefixSize + len(z.Holyday[za0008])
	}
	return
}
